{
  "_id": "6947c8744909a31c0b4674dd",
  "title": "Sending client-side logs to Graylog in a Next.js app",
  "slug": "sending-client-side-logs-to-graylog-in-a-nextjs-app",
  "excerpt": "As frontend apps grow, failures don’t just happen on the server.\n\nThey happen in:\n\n* hydration mismatches\n* broken third-party scripts\n* flaky networ...",
  "content": "\nAs frontend apps grow, failures don’t just happen on the server.\n\nThey happen in:\n\n* hydration mismatches\n* broken third-party scripts\n* flaky networks\n* race conditions between API + UI state\n* real devices we’ll never reproduce locally\n\nIf you’re not collecting **client-side logs**, you’re debugging blind.\n\nIn one of our Next.js apps, we started treating frontend logs as **first-class production signals**, and Graylog turned out to be a solid fit.\n\n---\n\n## Why Graylog for frontend logs?\n\nA few practical reasons:\n\n* Centralized: frontend + backend logs in one place\n* Structured logging (JSON, not console spam)\n* Searchable by user, route, build version\n* Alertable when patterns repeat\n\nMost importantly: it scales without inventing a custom logging backend.\n\n---\n\n## What we log from the client (and what we don’t)\n\nWe are strict here. Client logs can explode in volume.\n\nWe log:\n\n* Uncaught JS errors\n* API failures with context\n* Critical UI state mismatches\n* Performance signals (slow route, failed hydration)\n* Feature-level errors (checkout, payment, auth)\n\nWe **don’t** log:\n\n* Console.debug noise\n* User PII\n* Every click or render\n* Stack traces without context\n\nEvery log answers one question:\n\n> “Can this help us debug a real production issue?”\n\n---\n\n## Next.js architecture for client → Graylog\n\n### High-level flow\n\n```\nBrowser\n  ↓\nNext.js API route (/api/log)\n  ↓\nGraylog HTTP GELF input\n```\n\nWhy not send logs directly from the browser to Graylog?\n\n* Exposes Graylog publicly ❌\n* No auth / validation ❌\n* No filtering or sampling ❌\n\nThe **API route acts as a gatekeeper**.\n\n---\n\n## Client-side logging (minimal, intentional)\n\n```ts\nexport function logError(payload) {\n  fetch('/api/log', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      level: 'error',\n      message: payload.message,\n      stack: payload.stack,\n      route: window.location.pathname,\n      buildId: process.env.NEXT_PUBLIC_BUILD_ID,\n      userAgent: navigator.userAgent,\n      timestamp: Date.now()\n    })\n  });\n}\n```\n\nThis is usually triggered from:\n\n* global error boundary\n* `window.onerror`\n* failed API interceptors\n\n---\n\n## API route → Graylog (server-side)\n\n```ts\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).end();\n  }\n\n  try {\n    await fetch(process.env.GRAYLOG_ENDPOINT, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        version: '1.1',\n        host: 'nextjs-frontend',\n        short_message: req.body.message,\n        full_message: req.body.stack,\n        level: 3,\n        _route: req.body.route,\n        _buildId: req.body.buildId,\n        _userAgent: req.body.userAgent\n      })\n    });\n\n    res.status(200).end();\n  } catch (e) {\n    // Fail silently — logging should never break UX\n    res.status(200).end();\n  }\n}\n```\n\nKey points:\n\n* Logs should **never block the user**\n* Failures in logging must be invisible\n* Add rate-limiting & sampling early\n\n---\n\n## What actually helped in production\n\nReal wins we saw:\n\n* Identified hydration errors caused by **dynamic imports**\n* Caught broken releases via spike in a single route\n* Debugged device-specific bugs we couldn’t reproduce\n* Correlated frontend crashes with backend timeouts\n\nMost importantly:\n\n> Issues were debugged in minutes instead of days.\n\n---\n\n## Lessons learned\n\n1. **Frontend logs are not optional anymore**\n2. Structure your logs or they’re useless\n3. Sampling is mandatory\n4. Logs without context are noise\n5. Treat logging infra as production code\n\nFrontend engineering isn’t just UI.\nIt’s observability, resilience, and feedback loops.\n\n---\n\nIf you’re running Next.js at scale and still relying on `console.error`, you’re missing critical signals from real users.\n\nWould love to hear how others are handling frontend observability.\n",
  "tags": [
    "graylogs",
    "next",
    "frontend"
  ],
  "published": true,
  "featured": false,
  "views": 6,
  "likes": 0,
  "createdAt": "2025-12-21T10:14:12.763Z",
  "updatedAt": "2025-12-21T10:14:12.763Z",
  "__v": 0
}